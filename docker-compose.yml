services:

  firewall:
    build:
      context: ./firewall
      dockerfile: Dockerfile
    container_name: firewall
    restart: unless-stopped
    depends_on:
      - reverse-proxy
    ports:
      - "${FIREWALL_PORT}:${FIREWALL_PORT}"
    volumes:
      - shared_logs:/var/log/shared
      - ./firewall/rules.json:/var/log/shared/firewall/rules.json:Z
    env_file:
      - .env
    networks:
      - clients
    privileged: true
    cap_add:
      - NET_ADMIN
      - NET_RAW
    sysctls:
      net.ipv4.tcp_syncookies: '1'
      net.ipv4.tcp_max_syn_backlog: '4096'
      net.core.somaxconn: '4096'
      net.ipv4.tcp_synack_retries: '2'
      net.ipv4.tcp_syn_retries: '2'

  reverse-proxy:
    build:
      context: ./reverse-proxy/
      dockerfile: Dockerfile
    container_name: reverse-proxy
    restart: unless-stopped
    depends_on:
      - client
      - server
    ports:
      - "${REVERSE_PROXY_PORT}:8080"
    networks:
      - clients
      - servers
    volumes:
      - shared_logs:/var/log/shared
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080"]
      interval: 30s
      timeout: 3s
      retries: 3

  redis:
    image: redis:7-alpine
    container_name: redis_storage
    restart: unless-stopped
    command: ["redis-server", "--appendonly", "yes", "--requirepass", "${REDIS_PASSWORD}"]
    networks:
      - servers
    volumes:
      - redis_data:/data
      - shared_logs:/var/log/shared
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 3s
      retries: 3

  server:
    build:
      context: ./backend-servers/server/
      dockerfile: Dockerfile
    restart: unless-stopped
    depends_on:
      redis:
        condition: service_healthy
    expose:
      - ${SERVER_PORT}
    networks:
      - servers
    volumes:
      - shared_logs:/var/log/shared
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${SERVER_PORT}/status"]
      interval: 30s
      timeout: 3s
      retries: 3

  client:
    build:
      context: ./client/
      dockerfile: Dockerfile
    container_name: client
    restart: unless-stopped
    expose:
      - "${CLIENT_PORT}"
    networks:
      - clients
    volumes:
      - shared_logs:/var/log/shared
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${CLIENT_PORT}"]
      interval: 30s
      timeout: 3s
      retries: 3

  client_terminal:
    build:
      context: ./client_terminal/
      dockerfile: Dockerfile
    container_name: client_terminal
    restart: unless-stopped
    depends_on:
      - firewall
    networks:
      - clients
    volumes:
      - ./client_terminal:/app
    stdin_open: true
    tty: true
    profiles:
      - client_terminal

  dashboard:
    build:
      context: ./dashboard/
      dockerfile: Dockerfile
    container_name: dashboard
    restart: unless-stopped
    depends_on:
      - redis
    expose:
      - ${DASHBOARD_PORT}
    networks:
      - clients
      - servers
    volumes:
      - redis_data:/app/redis_data:ro
      - shared_logs:/var/log/shared
      - ./firewall/rules.json:/var/log/shared/firewall/rules.json:Z
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${DASHBOARD_PORT}"]
      interval: 30s
      timeout: 3s
      retries: 3


volumes:
  shared_logs:
    driver: local
  redis_data:
    driver: local

networks:
  clients:
  servers: